"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const basicAuthParser = require("basic-auth-parser");
const Promise = require("bluebird");
const events_1 = require("events");
const http = require("http");
const MiddlewareHandler = require("middleware-handler");
const net = require("net");
const url = require("url");
MiddlewareHandler.prototype = Promise.promisifyAll(MiddlewareHandler.prototype);
const connectSocket = ({ cltSocket, hostname, port, head, connect, req }) => connect(port, hostname, cltSocket, req)
    .then((srvSocket) => {
    cltSocket.write('HTTP/1.0 200 Connection Established\r\nProxy-agent: Resin-VPN\r\n\r\n');
    srvSocket.write(head);
    srvSocket.pipe(cltSocket, { end: false });
    cltSocket.pipe(srvSocket, { end: false });
    return Promise.fromCallback((cb) => {
        cltSocket.on('error', cb);
        srvSocket.on('error', cb);
        cltSocket.on('end', cb);
        srvSocket.on('end', cb);
    }).finally(() => {
        srvSocket.destroy();
        cltSocket.destroy();
    });
}).tapCatch(() => {
    cltSocket.end('HTTP/1.0 500 Internal Server Error\r\n');
    cltSocket.destroy();
});
class Request extends http.IncomingMessage {
}
exports.Request = Request;
class Tunnel extends events_1.EventEmitter {
    constructor() {
        super();
        this.server = http.createServer((_req, res) => {
            res.writeHead(405, { 'Content-Type': 'text/plain' });
            res.end('Method not allowed');
        });
        this.middleware = new MiddlewareHandler();
        this.use = this.middleware.use.bind(this.middleware);
        this.listen = this.server.listen.bind(this.server);
        this.close = this.server.close.bind(this.server);
        this.use(exports.basicAuth);
        this.server.on('connect', (req, cltSocket, head) => this.middleware.handleAsync([req, cltSocket, head])
            .then(() => {
            const { hostname, port } = url.parse(`http://${req.url}`);
            if (hostname == null || port == null) {
                throw new Error('Invalid Request: Hostname or Port missing');
            }
            return connectSocket({
                cltSocket,
                hostname,
                port: parseInt(port, 10),
                head,
                connect: this.connect,
                req,
            })
                .then(() => this.emit('connect', hostname, port, head));
        }).catch((err) => {
            this.emit('error', err);
            cltSocket.destroy();
        }));
    }
    connect(port, host, _cltSocket, _req) {
        const socket = net.connect(port, host);
        return new Promise((resolve, reject) => {
            socket.on('connect', () => resolve(socket));
            socket.on('error', reject);
        });
    }
}
exports.Tunnel = Tunnel;
exports.createTunnel = () => new Tunnel();
exports.basicAuth = (req, _cltSocket, _head, next) => {
    const proxyAuth = req.headers['proxy-authorization'];
    if (proxyAuth != null) {
        req.auth = basicAuthParser(proxyAuth);
    }
    return next();
};
//# sourceMappingURL=index.js.map